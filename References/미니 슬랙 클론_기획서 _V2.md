# 미니 프로젝트 기획서

## 1. 프로젝트 개요

본 프로젝트는 **채널 기반 실시간 채팅 서비스**를 구현하는 미니 프로젝트이다.  
FastAPI 단일 서버 구조를 기반으로 하며, 인증·채팅·결제(Stripe 테스트)를 하나의 서비스 흐름으로 경험하는 것을 목표로 한다.

- 목적: 실시간 채팅 + 인증 + 결제 구조 학습
- 범위: MVP 수준 (기능 최소화, 구조 명확화)
- 대상: 학습 및 구조 설계 중심 프로젝트

---

## 2. 기술 스택

### 서버

- FastAPI (단일 서버)
- MySQL (영속 데이터 저장)
- Mosquitto MQTT (실시간 전달 전용)

### 클라이언트

- Flutter
- MVVM 구조
- SQLite (전송 큐 + 로컬 캐시)


### 인증 / 결제

- 이메일 OTP 기반 패스워드리스 인증
- 세션 토큰 방식(랜덤 토큰)
- Stripe 테스트 모드 결제

---

## 3. 인증 서비스 (S1)

### 3.1 인증 방식

- 이메일 기반 OTP 인증
- 비밀번호 사용하지 않음 (패스워드리스)

### 3.2 인증 흐름

1. 사용자가 이메일 입력
2. 서버가 OTP 숫자 메일 발송
3. 사용자가 OTP 입력
4. OTP 검증 성공 시:
   - 사용자 자동 생성(최초 1회)
   - 세션 토큰 발급

### 3.3 로그인 유지

- 세션 토큰을 클라이언트에 저장
- 세션 만료 전까지 자동 로그인
- 로그아웃 또는 만료 시 OTP 재인증

---

## 4. 채널 서비스 (S2)

### 4.1 채널 개념

- 채널은 여러 사용자가 메시지를 주고받는 공간
- 기본 채널은 서버에 미리 정의됨

### 4.2 사용자 등급

- **Free**: 기본 채널만 사용
- **Plus**: 개인 전용 채널 생성 가능
- **Pro**: 개인 채널 + 비밀번호 채널 생성 가능

### 4.3 채널 유형

1. 기본 채널
   - 로그인 사용자 누구나 입장 가능

2. 개인 채널
   - 채널 생성자만 입장 가능

3. 비밀번호 채널
   - 비밀번호 인증 성공 시 입장 가능

---

## 5. 메시지 서비스 (S3)

### 5.1 메시지 기본 규칙

- 메시지는 텍스트만 지원
- 파일/이미지 전송은 제외

### 5.2 메시지 전송 방식

- 메시지는 **서버 저장 성공을 기준으로 처리**한다.
- 서버 저장에 실패한 메시지는 다른 사용자에게 전달되지 않는다.

#### 5.2.1 messageId 기반 중복 방지 (권장)

MQTT 환경에서는 동일 메시지가 중복 전달될 수 있으므로, 서버에서 생성한 `messageId`를 기준으로 클라이언트에서 중복을 제거한다.

1. 클라이언트 → 서버(FastAPI)로 메시지 전송
2. 서버가 DB에 메시지 저장 후 `messageId` 생성
3. 서버가 MQTT로 메시지 전달 (`messageId` 포함)
4. 클라이언트는 수신 시 `messageId` 기준으로 중복 제거

### 5.3 메시지 정렬

- 메시지 순서는 서버 저장 순서를 기준으로 한다.

### 5.4 메시지 조회

- 채널 입장 시 최근 메시지 조회
- 스크롤 시 이전 메시지 추가 조회

---

## 6. 클라이언트 로컬 저장 전략 (SQLite)

### 6.1 도입 목적

본 프로젝트는 Firebase와 같은 외부 BaaS의 자동 동기화 기능을 사용하지 않는다.  
대신 **클라이언트 앱 내부에 로컬 저장소(SQLite)를 두어**, 네트워크 지연이나 일시적인 연결 문제 상황에서도 **메시지 입력과 화면 사용이 끊기지 않도록** 설계한다.

SQLite는 서버(MySQL)를 대체하지 않으며, **사용자 경험 안정성을 위한 보조 수단**으로만 사용된다.

---

### 6.2 메시지 전송 임시 저장 (전송 큐)

- 사용자가 메시지를 입력하면, 서버로 전송하기 전에 **앱 내부에 먼저 임시 저장**된다.
- 이를 통해 다음과 같은 상황에서도 메시지 입력이 보존된다.
  - 네트워크가 느리거나 일시적으로 끊긴 경우
  - 앱이 백그라운드로 이동하거나 재시작된 경우

- 메시지는 내부적으로 다음과 같은 흐름으로 관리된다.
  - 전송 대기: 아직 서버로 전달되지 않은 상태
  - 전송 중: 서버로 전달을 시도하는 상태
  - 전송 완료: 서버에 정상적으로 저장된 상태
  - 전송 실패: 일시적 오류로 전달되지 않은 상태

- 서버는 클라이언트가 전달한 식별 값을 기준으로 중복 저장을 방지한다.

---

### 6.3 최근 메시지 보관 (로컬 캐시)

- 서버에 정상적으로 저장된 메시지는 **최근 대화 기록 위주로 앱 내부에 보관**할 수 있다.
- 목적은 다음과 같다.
  - 채널 입장 시 빠른 초기 화면 표시
  - 스크롤 이동 시 부드러운 메시지 로딩
  - 짧은 네트워크 지연 상황에서도 대화 맥락 유지

- 로컬에 보관된 메시지는 언제든 서버 데이터로 재동기화할 수 있으며, **데이터의 최종 기준은 항상 서버(MySQL)** 이다.

---

### 6.4 서버·실시간 전달과의 역할 분리

- 서버(MySQL): 모든 메시지 데이터의 **최종 저장소**
- SQLite: 메시지 유실 방지 및 UI 안정성 확보
- MQTT/WebSocket: **이미 저장된 메시지를 즉시 알리는 전달 전용 수단**

---

## 7. 실시간 전달 서비스 (S4)

### 7.1 역할 정의

- 실시간 전달은 저장된 메시지를 즉시 알리는 역할만 담당
- 데이터 저장 기능 없음

### 7.2 전달 규칙

- 메시지 저장 성공 후에만 전달
- 채널에 입장 중인 사용자에게만 전달

### 7.3 MQTT 토픽 구조

```
chat/channel/{channelId}
```

---

## 8. 메시지 UI 표현 규칙

### 8.1 발신자 표시

- 동일 사용자의 연속 메시지는 묶어서 표시
- 발신자 이름은 묶음의 첫 메시지에만 표시

### 8.2 시스템 메시지

- 시스템 메시지는 일반 메시지와 구분된 스타일로 표시

### 8.3 프로필 이미지 정책

- 메시지 화면에는 프로필 이미지를 표시하지 않음
- 메시지는 텍스트 중심으로 표현

---

## 9. 결제 서비스 (S5)

### 9.1 결제 목적

- 유료 기능 해금 구조 학습
- 실제 금전 거래 목적 아님

### 9.2 결제 방식

- Stripe 테스트 모드 사용
- 기간형 이용권
- 자동 갱신 없음

### 9.3 유료 모델

- Plus → 개인 채널 생성
- Pro → 개인 채널 + 비밀번호 채널

---

## 10. 향후 확장(옵션)

- 운영/통계 페이지
- QA 전용 채널
- 고객 Q&A(티켓형)

---

## 11. 프로젝트 범위에서 제외한 항목

- 파일/이미지 메시지
- 읽음/타이핑 표시
- 알림
- 자동 결제

---

## 12. 중요 포인트 요약

1. 서버(MySQL)가 항상 데이터의 기준
2. MQTT는 전달 전용
3. SQLite는 클라이언트 안정성 확보를 위한 보조 수단

